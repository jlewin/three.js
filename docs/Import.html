<html>
	<head>
		<style type="text/css">
			body {
				font-family: sans-serif;
			}
			#allTypes {
				margin: 0;
				padding: 10px;
				overflow: auto;
			}

				#allTypes li {
					list-style: none;
					margin: 2px;
					display: inline-block;
					background: #ddd;
					border-radius: 3px 4px;
					padding: 2px 5px;
					font-size: xx-small;
					cursor: pointer;
				}

			#results {
				width: 400px;
				height: 590px;
				float: right;
				background: #ccc;
				border: solid 1px #ddd;
				padding: 5px;
				overflow: scroll;
			}

				#results .expected {
					font-weight: bold;
					color: #576AF1;
				}

				#results td,
				#results th {
					font-size: xx-small;
					text-align: left;
				}

				#results .heading {
					border-bottom: solid 1px #F17777;
					padding: 3px;
				}

				#results td.pass,
				#results td.fail {
					background: url(images/tick.png) no-repeat;
					width: 16px;
					height: 16px;
					padding: 0;
				}

				#results td.fail {
					background-position: 0 -16px;
				}

		</style>
	</head>
	<body>
		<script src="../build/three.js"></script>

		<script src="ParseHelpDocs.js"></script>
		<script src="list.js"></script>
		<script src="TestHelpDocs.js"></script>

		<script src="../examples/fonts/helvetiker_regular.typeface.js"></script>

		<script id="dyn"></script>

		<iframe id="mash" style="width: 100%; height: 600px;"></iframe>

		<div id="results"></div>

		<ul id="allTypes"></ul>

		<script>

			var key = 'allTypes';
			var types = [];
			var activeItem;
			var collected = [];
			var helpDocs = {};
			var imported = 0;
			var MAX_IMPORT = 10;
			var IMPORT_SKIP_COUNT = 32;
			var errors = [];

			var xhr = new XMLHttpRequest();

			function syncLoadScript(path) {

				xhr.open("GET", path, false);
				xhr.send(null);

				if (xhr.status == '404') {
					throw 'Error loading script';
				}

				return xhr.responseText;

			}

			function getProtoName(js) {

				var protoAssign = /\.prototype\s*=\s*[^\n]*THREE.([^)\n\s]*)/.exec(js);
				return (protoAssign && protoAssign.length > 0) ? protoAssign[1] : null;

			}

			function getSuperName(js) {

				var baseCall = /THREE\.([^\s]*)\.(call|apply)/.exec(js);
				return (baseCall && baseCall.length > 0) ? baseCall[1] : null;

			}

			function compareTypes(instance, base) {

				var local = [];
				var remote = [];
				var overridden = [];

				for (var p in instance)
				{
					var baseVal = base[p];
					var instVal = instance[p];

					var baseType = typeof baseVal;
					var instType = typeof instVal;

					if (p in base) {
						if (baseType == 'function' && !equals(instVal, baseVal, instType, baseType))
							overridden.push(p);
						else
							remote.push(p);
					} else {
						local.push(p)
					}
				}

				return { local: local, remote: remote, overridden: overridden };

			}

			function equals(dis, dat, typeA, typeB) {

				if (typeA != typeB) return false;

				
				switch (typeA) {
					case 'object':
						if (Array.isArray(dis)) {
							return JSON.stringify(dis) == JSON.stringify(dat);
						} else {
							return dis === dat; break;
						}
					case 'function':
						return dis.toString() == dat.toString(); break;
					default:
						return dis == dat; break;
				}
			}

			function showClickedItem(e) {

				// Display the help docs
				mash.src = e.srcElement.getAttribute('data-url');

				var name = e.srcElement.textContent;
				var helpDoc = helpDocs[name];
				var categorized;

				var protoName = helpDoc.protoName;
				var superName = helpDoc.superName;
				var instance = typeMap.getInstance(name);

				if (superName || protoName) {
					// Compare the instance against its proto to decipher inheritance
					categorized = compareTypes(instance, typeMap.getInstance(superName || protoName))
				} else {
					categorized = inspectInstance(instance);
				}

				var table = validateDocs(name, instance, helpDoc, categorized);

				var elem = document.getElementById('results');
				elem.innerHTML = '';
				elem.appendChild(table);

			}

			var ul = document.getElementById('allTypes');
			ul.addEventListener('click', showClickedItem, false);

			var mash = document.getElementById('mash');
			mash.onload = function () {

				// Process the help documentation for the given item
				var helpDoc = processHelpPage(mash.contentDocument.body);
				helpDoc.helpClassName = activeItem[0];
				helpDoc.helpUrl = activeItem[1] + '.html';

				// Process the script
				var scriptUrl = '../' + helpDoc.Source[0].local;

				try {

					var js = syncLoadScript(scriptUrl);

					helpDoc.protoName = getProtoName(js);
					helpDoc.superName = getSuperName(js);

					collected.push(helpDoc);

				} catch (e) {

					console.log(e.message);
					helpDoc.error = e.message;
					errors.push({ message: e.message, doc: helpDoc });

				}

				window.setTimeout(popLoadType, 500);

			};


			init();

			function init() {

				var json = window.localStorage[key];
				if (!json) {

					// Flatten the type info from the lists object into a hash of objectName -> path
					for (var i in list.Reference) {

						list.Reference[i].forEach(function (t) {

							types.push(t);

						});

					}

					if (IMPORT_SKIP_COUNT > 0) {
						for (var i = 0; i < IMPORT_SKIP_COUNT; i++) {
							types.pop();
						}
					}

					// Start processing the queue
					popLoadType();

				} else {

					collected = JSON.parse(json);
					typesLoaded();

				}

			}

			function typesLoaded() {

				var item,
					li;

				allTypes.innerHTML = '';

				for (var i = 0, length = collected.length; i < length; i++) {

					item = collected[i];

					li = document.createElement('li');
					li.innerHTML = item.helpClassName;
					li.setAttribute('data-url', item.helpUrl);
					allTypes.appendChild(li);
				}

				mash.style.width = 'calc(100% - 430px)';
				mash.onload = null;

				helpDocs = {};

				// Loop over all collected docs building out the helpDocs
				// object for indexed lookup as well as populating the members
				// property for the same reason
				collected.forEach(function (doc) {

					doc.members = {};

					// Build members prop
					[doc.Properties, doc.Methods].forEach(function (section) {

						if (section && section.length > 0) {

							for (var i = 0, length = section.length; i < length; i++) {
								var item = section[i];
								doc.members[item.name] = item;
							}
						}
					});

					// Assign doc
					helpDocs[doc.helpClassName] = doc;

				});

			}

			function popLoadType() {

				activeItem = types.pop();

				if (activeItem && imported < MAX_IMPORT) {

					loadPage(activeItem);

				} else {
					window.localStorage[key] = JSON.stringify(collected);
					typesLoaded();
				}

			}

			function loadPage(page) {
				//console.log('Loading ' + page[0]);
				mash.src = page[1] + '.html';
				imported++;

			}

		</script>

	</body>
</html>

